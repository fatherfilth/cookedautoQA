---
phase: 05-ci-cd-alerting
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - scripts/notify-slack.js
  - .env.example
autonomous: true

must_haves:
  truths:
    - "Slack notification is sent on test failure with failing test names and GitHub Actions run link"
    - "Slack message includes links to artifact pages (reports and traces)"
    - "Alerts categorize failures by severity (CRITICAL vs WARNING based on @critical/@warning tags)"
    - "Consecutive failure tracking requires 2+ failures before sending alert to reduce noise"
    - "JSON summary with timestamp, commit SHA, test names, pass/fail, duration, and error summary is generated"
  artifacts:
    - path: "scripts/notify-slack.js"
      provides: "Combined alerting script: parses Playwright JSON results, tracks consecutive failures, categorizes by severity, sends Slack Block Kit notifications, writes JSON summary"
      min_lines: 150
    - path: ".env.example"
      provides: "Updated env documentation with SLACK_WEBHOOK_URL"
      contains: "SLACK_WEBHOOK_URL"
  key_links:
    - from: "scripts/notify-slack.js"
      to: "test-results/results.json"
      via: "fs.readFile to parse Playwright JSON report"
      pattern: "readFile.*results\\.json"
    - from: "scripts/notify-slack.js"
      to: ".state/failure-state.json"
      via: "read/write for consecutive failure tracking"
      pattern: "failure-state\\.json"
    - from: ".github/workflows/playwright.yml"
      to: "scripts/notify-slack.js"
      via: "workflow failure step runs this script"
      pattern: "node scripts/notify-slack\\.js"
---

<objective>
Create the Slack alerting and reporting script that parses Playwright JSON results, tracks consecutive failures across runs, categorizes failures by severity (@critical vs @warning tags), and sends rich Slack Block Kit notifications with links to the GitHub Actions run and artifacts. Also generates a JSON summary report per run.

Purpose: Without alerting, test failures go unnoticed until someone manually checks GitHub Actions. This script closes the feedback loop: tests fail -> script parses results -> checks if failure is consecutive -> sends severity-appropriate Slack alert with actionable links. The JSON summary enables historical trend analysis.

Output: `scripts/notify-slack.js` (combined parsing, tracking, alerting, and reporting script), updated `.env.example`.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-ci-cd-alerting/05-RESEARCH.md

# Existing files
@.env.example
@tests/helpers/test-config.ts (Tags.CRITICAL and Tags.WARNING constants)
@scripts/.gitkeep (scripts directory exists)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create combined Slack notification script with severity logic, consecutive failure tracking, and JSON summary</name>
  <files>
    scripts/notify-slack.js
  </files>
  <action>
Create `scripts/notify-slack.js` as a single ESM JavaScript file (not TypeScript — this runs in CI via `node scripts/notify-slack.js` without compilation). Use `.js` extension consistent with ESM `"type": "module"` in package.json.

The script combines four concerns into one file to keep the CI step simple (single `node` invocation):
1. Parse Playwright JSON results
2. Track consecutive failures
3. Categorize by severity and decide whether to alert
4. Send Slack Block Kit notification
5. Write JSON summary report

**Script structure:**

```javascript
// scripts/notify-slack.js
// Parses Playwright JSON results, tracks consecutive failures,
// sends severity-based Slack alerts via Block Kit, and writes JSON summary.

import fs from 'fs/promises';
import path from 'path';
```

**Section 1: Constants and configuration**

```javascript
const RESULTS_FILE = 'test-results/results.json';
const STATE_FILE = '.state/failure-state.json';
const SUMMARY_FILE = 'test-results/summary.json';
const ALERT_THRESHOLD = 2; // Consecutive failures before alerting (ALERT-04)
```

**Section 2: Parse Playwright JSON results**

Function `parseResults()`:
- Read `test-results/results.json` via `fs.readFile`
- Parse JSON
- Walk the nested structure: `report.suites[].suites[].specs[].tests[]` (note: suites can be nested when using `test.describe`)
- For each spec, extract: `title`, `file` (from parent suite), `tags` (array on spec), `status` (from first test entry: "expected" = pass, "unexpected" = fail, "flaky" = flaky, "skipped" = skip), `duration`, `errors` (from test.results[].errors)
- Return structured object: `{ passed: TestResult[], failed: TestResult[], flaky: TestResult[], skipped: TestResult[], stats: report.stats }`
- Handle nested suites recursively (suites can contain child suites)

TestResult shape: `{ title: string, file: string, tags: string[], status: string, duration: number, error: string }`

Important: Playwright JSON structure has `suites` which can contain nested `suites` AND `specs`. Walk recursively:
```javascript
function extractSpecs(suites, parentFile = '') {
  const results = [];
  for (const suite of suites) {
    const file = suite.file || parentFile;
    // Process specs in this suite
    for (const spec of (suite.specs || [])) {
      const test = spec.tests?.[0];
      if (!test) continue;
      results.push({
        title: spec.title,
        file,
        tags: spec.tags || [],
        status: test.status,  // "expected", "unexpected", "flaky", "skipped"
        duration: test.results?.[0]?.duration || 0,
        error: test.results?.[0]?.errors?.[0]?.message || '',
      });
    }
    // Recurse into child suites
    if (suite.suites?.length) {
      results.push(...extractSpecs(suite.suites, file));
    }
  }
  return results;
}
```

**Section 3: Consecutive failure tracking**

Function `loadState()`: Read `.state/failure-state.json`. If file doesn't exist (ENOENT), return empty object `{}`.

Function `saveState(state)`: Create `.state/` directory (recursive), write JSON with 2-space indent.

Function `trackFailures(results)`:
- Load state
- For each failed test: increment counter (or initialize to 1). Update lastFailure timestamp.
- For each passed test: delete from state (reset counter on recovery).
- Save state
- Return array of tests that have reached the alert threshold (count >= ALERT_THRESHOLD)
- Include `consecutiveFailures` count in returned test objects

**Section 4: Severity categorization**

Function `categorizeFailures(tests)`:
- Split into `critical` (tags include '@critical') and `warning` (tags include '@warning' OR no severity tag — default untagged to warning)
- Return `{ critical: TestResult[], warning: TestResult[] }`

Per ALERT-03: CRITICAL flows = game launch, login, registration. WARNING flows = tipping, Latest & Greatest, navigation, lobby, search. The tags on the tests themselves determine categorization (set in Plan 3).

**Section 5: Slack Block Kit message builder**

Function `buildSlackPayload({ severity, failures, runUrl, commit, branch })`:

Build a Slack Block Kit payload with these blocks:
1. **Header block**: `"{emoji} {severity} Test Failures — cooked.com"` where emoji is the unicode character for a rotating light for CRITICAL (U+1F6A8) and warning sign for WARNING (U+26A0 U+FE0F).
2. **Section with fields**: Severity field and Failed Tests count field.
3. **Section**: List of failed test names as bullet points (mrkdwn format: `• {test.title} ({test.consecutiveFailures}x consecutive)`)
4. **Section**: Error snippets — first 100 chars of each error message, truncated with "..."
5. **Section with links**: Links to GitHub Actions run page and artifacts page using `<url|display text>` Slack mrkdwn syntax.
6. **Divider block**
7. **Context block**: Commit SHA (first 7 chars), branch name, timestamp (ISO 8601).

Truncate failed test list to first 10 tests if more than 10 (add "...and N more" line). Block Kit has a 50-block limit — keep messages concise.

**Section 6: Send Slack notification**

Function `sendSlackAlert(payload)`:
- POST to `process.env.SLACK_WEBHOOK_URL` using built-in `fetch`
- Set `Content-Type: application/json`
- Check response.ok — if not, log error with status and body text
- If SLACK_WEBHOOK_URL is not set, log warning and skip (don't error — allows local testing of the script)

**Section 7: Write JSON summary report**

Function `writeSummary(results, stats)`:
- Write `test-results/summary.json` with structure (REPORT-01):
```json
{
  "timestamp": "ISO 8601 string",
  "commit": "first 7 chars of GITHUB_SHA or 'local'",
  "branch": "GITHUB_REF_NAME or 'local'",
  "runId": "GITHUB_RUN_ID or null",
  "runUrl": "full URL or null",
  "duration": stats.duration,
  "total": passed.length + failed.length + flaky.length + skipped.length,
  "passed": passed.length,
  "failed": failed.length,
  "flaky": flaky.length,
  "skipped": skipped.length,
  "failures": [
    {
      "title": "test name",
      "file": "test file path",
      "tags": ["@critical"],
      "duration": 1234,
      "error": "truncated error message (first 200 chars)"
    }
  ]
}
```

**Section 8: Main function**

```javascript
async function main() {
  // 1. Parse results
  const results = await parseResults();

  // 2. Write JSON summary (always, even if no failures)
  await writeSummary(results);

  // 3. If no failures, log success and exit
  if (results.failed.length === 0) {
    console.log(`All ${results.passed.length} tests passed.`);
    return;
  }

  console.log(`${results.failed.length} test(s) failed.`);

  // 4. Track consecutive failures
  const alertableTests = await trackFailures(results);

  // 5. If no tests have reached threshold, log and exit
  if (alertableTests.length === 0) {
    console.log('Failures detected but below consecutive threshold. No alert sent.');
    return;
  }

  // 6. Categorize by severity
  const { critical, warning } = categorizeFailures(alertableTests);

  // 7. Build URLs
  const runUrl = process.env.GITHUB_RUN_ID && process.env.GITHUB_REPOSITORY
    ? `https://github.com/${process.env.GITHUB_REPOSITORY}/actions/runs/${process.env.GITHUB_RUN_ID}`
    : null;
  const commit = (process.env.GITHUB_SHA || 'local').substring(0, 7);
  const branch = process.env.GITHUB_REF_NAME || 'local';

  // 8. Send alerts (separate messages for CRITICAL and WARNING)
  if (critical.length > 0) {
    const payload = buildSlackPayload({
      severity: 'CRITICAL',
      failures: critical,
      runUrl,
      commit,
      branch,
    });
    await sendSlackAlert(payload);
  }

  if (warning.length > 0) {
    const payload = buildSlackPayload({
      severity: 'WARNING',
      failures: warning,
      runUrl,
      commit,
      branch,
    });
    await sendSlackAlert(payload);
  }
}

main().catch(err => {
  console.error('Notification script failed:', err);
  process.exit(1);
});
```

**Error handling:**
- If `test-results/results.json` doesn't exist, log error and exit with code 1 (CI step will show as failed)
- If Slack webhook URL is not set, log warning "SLACK_WEBHOOK_URL not set, skipping Slack notification" and continue (still write summary)
- If Slack API returns error, log but don't exit with error (alerting failure shouldn't fail the CI step)
- If state file operations fail for non-ENOENT reasons, log error and continue without consecutive tracking (still send alert)
  </action>
  <verify>
    Run `node --check scripts/notify-slack.js` — syntax check passes (no syntax errors).
    Confirm file uses ESM imports (import fs from 'fs/promises', not require).
    Confirm ALERT_THRESHOLD is set to 2.
    Confirm RESULTS_FILE path matches playwright.config.ts JSON reporter output path (test-results/results.json).
    Confirm STATE_FILE path matches .gitignore entry (.state/failure-state.json).
    Confirm categorizeFailures defaults untagged tests to WARNING severity.
    Confirm Slack payload uses Block Kit format (blocks array with type: 'header', type: 'section', etc.).
    Confirm summary JSON includes all required fields: timestamp, commit, branch, duration, total, passed, failed, flaky, skipped, failures array.
    Confirm SLACK_WEBHOOK_URL absence is handled gracefully (log warning, don't error).
  </verify>
  <done>
    scripts/notify-slack.js exists as a single ESM script that: (1) parses Playwright JSON results from test-results/results.json, (2) tracks consecutive failures in .state/failure-state.json with threshold of 2, (3) categorizes failures as CRITICAL or WARNING based on @critical/@warning tags, (4) sends Slack Block Kit notifications with test names, error snippets, and links to GitHub Actions run and artifacts, (5) writes JSON summary to test-results/summary.json with all required fields.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update .env.example with alerting environment variables</name>
  <files>
    .env.example
  </files>
  <action>
The `.env.example` file already has a placeholder for `SLACK_WEBHOOK_URL` (added in Phase 1 — line reads `SLACK_WEBHOOK_URL=`). Verify it exists and has the correct comment.

If the existing line is just `SLACK_WEBHOOK_URL=` without a descriptive comment, update the alerting section to be more descriptive:

Find the existing `# Alerting (Phase 5)` section and update it to:

```
# Alerting (Phase 5)
# Slack incoming webhook URL for failure notifications
# Create at: https://api.slack.com/messaging/webhooks
# Leave empty to skip Slack notifications (script will log warning and continue)
SLACK_WEBHOOK_URL=
```

Do NOT change any other existing lines in .env.example.
  </action>
  <verify>
    Confirm .env.example has SLACK_WEBHOOK_URL with descriptive comments.
    Confirm no existing env vars were removed or modified.
  </verify>
  <done>
    .env.example documents SLACK_WEBHOOK_URL with setup instructions and graceful-skip behavior note.
  </done>
</task>

</tasks>

<verification>
1. `node --check scripts/notify-slack.js` passes (no syntax errors)
2. Script uses ESM imports (import, not require)
3. Script reads from `test-results/results.json` (matches playwright.config.ts JSON reporter output)
4. Script writes state to `.state/failure-state.json` (matches .gitignore from Plan 1)
5. Script writes summary to `test-results/summary.json`
6. ALERT_THRESHOLD constant equals 2
7. Consecutive failure tracking: first failure = no alert, second consecutive = alert
8. Severity categorization: @critical tag -> CRITICAL, @warning or untagged -> WARNING
9. Slack payload uses Block Kit format (not legacy attachments)
10. Slack message includes: failing test names, severity level, GitHub Actions run link, artifacts link
11. Missing SLACK_WEBHOOK_URL handled gracefully (warning, not error)
12. .env.example documents SLACK_WEBHOOK_URL
</verification>

<success_criteria>
- ALERT-01: Script sends Slack notification with failing test names and GitHub Actions run link
- ALERT-02: Slack message includes links to artifact pages (reports, traces)
- ALERT-03: Failures categorized as CRITICAL (@critical tag) or WARNING (@warning/untagged) with different message headers
- ALERT-04: Consecutive failure tracking with threshold of 2 — first failure is silent, second consecutive triggers alert
- REPORT-01: JSON summary generated with timestamp, commit SHA, test names, pass/fail, duration, error summary
</success_criteria>

<output>
After completion, create `.planning/phases/05-ci-cd-alerting/05-02-SUMMARY.md`
</output>

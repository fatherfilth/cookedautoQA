---
phase: 01-foundation-test-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - tests/helpers/test-config.ts
  - tests/helpers/retry.ts
  - tests/helpers/waits.ts
  - tests/pages/BasePage.ts
  - tests/pages/LobbyPage.ts
  - tests/pages/LoginPage.ts
  - tests/pages/RegistrationPage.ts
  - tests/pages/GameDetailPage.ts
  - tests/pages/AccountPage.ts
  - docs/SELECTOR-STRATEGY.md
autonomous: true

must_haves:
  truths:
    - "BasePage provides goto(), waitForReady(), and getByTestIdOrFallback() methods usable by all page objects"
    - "retryAction() retries a failed async operation 2-3 times with configurable delay"
    - "All page objects use role-based locators as primary, data-testid as fallback — no CSS class selectors"
    - "No page object uses networkidle or arbitrary sleep waits"
    - "Selector strategy is documented with priority order and examples"
    - "Page object shells exist for lobby, login, registration, game detail, and account pages"
  artifacts:
    - path: "tests/helpers/test-config.ts"
      provides: "Centralized configuration constants (timeouts, URLs, retry counts)"
      exports: ["config"]
    - path: "tests/helpers/retry.ts"
      provides: "Generic retry utility for flaky operations"
      exports: ["retryAction"]
    - path: "tests/helpers/waits.ts"
      provides: "Explicit wait helpers (waitForSpinnerGone, waitForApiResponse)"
      exports: ["waitForSpinnerGone", "waitForApiResponse"]
    - path: "tests/pages/BasePage.ts"
      provides: "Base page class with navigation, wait, and selector helpers"
      exports: ["BasePage"]
    - path: "tests/pages/LobbyPage.ts"
      provides: "Lobby page object shell"
      exports: ["LobbyPage"]
    - path: "tests/pages/LoginPage.ts"
      provides: "Login page object shell"
      exports: ["LoginPage"]
    - path: "tests/pages/RegistrationPage.ts"
      provides: "Registration page object shell"
      exports: ["RegistrationPage"]
    - path: "tests/pages/GameDetailPage.ts"
      provides: "Game detail page object shell"
      exports: ["GameDetailPage"]
    - path: "tests/pages/AccountPage.ts"
      provides: "Account page object shell"
      exports: ["AccountPage"]
    - path: "docs/SELECTOR-STRATEGY.md"
      provides: "Documented selector priority and patterns"
      contains: "getByRole"
  key_links:
    - from: "tests/pages/BasePage.ts"
      to: "tests/helpers/retry.ts"
      via: "BasePage imports retryAction for retry-wrapped navigation"
      pattern: "import.*retryAction.*from"
    - from: "tests/pages/BasePage.ts"
      to: "tests/helpers/test-config.ts"
      via: "BasePage imports config for timeout values"
      pattern: "import.*config.*from"
    - from: "tests/pages/LobbyPage.ts"
      to: "tests/pages/BasePage.ts"
      via: "LobbyPage extends BasePage"
      pattern: "extends BasePage"
    - from: "tests/pages/LoginPage.ts"
      to: "tests/pages/BasePage.ts"
      via: "LoginPage extends BasePage"
      pattern: "extends BasePage"
---

<objective>
Create the test helper utilities, Page Object Model base class, page object shells for key pages, and selector strategy documentation.

Purpose: Provide reusable building blocks that Phase 2+ tests will import. Bake reliability patterns (explicit waits, retry logic, stable selectors) into the base classes so individual tests inherit them automatically.
Output: Working helper modules, POM hierarchy, and selector strategy guide.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-test-infrastructure/01-RESEARCH.md
@.planning/phases/01-foundation-test-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create test helper utilities and BasePage class</name>
  <files>
    tests/helpers/test-config.ts
    tests/helpers/retry.ts
    tests/helpers/waits.ts
    tests/pages/BasePage.ts
  </files>
  <action>
    1. Create `tests/helpers/test-config.ts` — centralized configuration constants:
       ```typescript
       export const config = {
         timeouts: {
           action: 15_000,        // Click, fill, etc.
           navigation: 30_000,    // page.goto, page.waitForURL
           assertion: 10_000,     // expect() assertions
           spinner: 10_000,       // Wait for loading spinners to disappear
           apiResponse: 15_000,   // Wait for specific API response
         },
         retry: {
           maxAttempts: 3,        // RELY-01: retry 2-3 times
           delayMs: 1_000,        // Wait between retries
         },
         selectors: {
           // Common loading indicators to wait for disappearance
           spinners: [
             '[data-testid="loading-spinner"]',
             '[role="progressbar"]',
             '.loading-spinner',   // CSS fallback (last resort)
           ],
         },
       } as const;

       // Criticality tags for RELY-04
       export const Tags = {
         CRITICAL: '@critical',
         WARNING: '@warning',
         SMOKE: '@smoke',
       } as const;
       ```

    2. Create `tests/helpers/retry.ts` — generic retry utility (RELY-01):
       ```typescript
       import { config } from './test-config.js';

       /**
        * Retries an async action up to maxAttempts times before failing.
        * Used for operations that may be flaky due to timing (not for Playwright
        * locator actions which auto-retry via the Locator API).
        *
        * Use cases: API calls, navigation to dynamic URLs, custom state checks.
        * Do NOT use for: click(), fill(), expect() — these already auto-retry.
        */
       export async function retryAction<T>(
         action: () => Promise<T>,
         options?: {
           maxAttempts?: number;
           delayMs?: number;
           label?: string;
         }
       ): Promise<T> {
         const maxAttempts = options?.maxAttempts ?? config.retry.maxAttempts;
         const delayMs = options?.delayMs ?? config.retry.delayMs;
         const label = options?.label ?? 'action';
         let lastError: Error;

         for (let attempt = 1; attempt <= maxAttempts; attempt++) {
           try {
             return await action();
           } catch (error) {
             lastError = error as Error;
             if (attempt < maxAttempts) {
               console.warn(
                 `Retry ${attempt}/${maxAttempts} for "${label}": ${lastError.message}`
               );
               await new Promise(resolve => setTimeout(resolve, delayMs));
             }
           }
         }

         throw new Error(
           `"${label}" failed after ${maxAttempts} attempts. Last error: ${lastError!.message}`
         );
       }
       ```

    3. Create `tests/helpers/waits.ts` — explicit wait helpers (RELY-03):
       ```typescript
       import { Page } from '@playwright/test';
       import { config } from './test-config.js';

       /**
        * Wait for all known loading spinners to disappear.
        * Uses explicit waitForSelector with state: 'hidden' — NOT networkidle.
        */
       export async function waitForSpinnerGone(page: Page): Promise<void> {
         for (const selector of config.selectors.spinners) {
           const spinner = page.locator(selector).first();
           // Only wait if spinner exists — don't fail if it was never shown
           const isVisible = await spinner.isVisible().catch(() => false);
           if (isVisible) {
             await spinner.waitFor({
               state: 'hidden',
               timeout: config.timeouts.spinner,
             });
           }
         }
       }

       /**
        * Wait for a specific API response matching the URL pattern.
        * Use instead of networkidle for SPAs.
        */
       export async function waitForApiResponse(
         page: Page,
         urlPattern: string | RegExp,
         options?: { status?: number; timeout?: number }
       ): Promise<void> {
         const timeout = options?.timeout ?? config.timeouts.apiResponse;
         const status = options?.status ?? 200;

         await page.waitForResponse(
           response => {
             const urlMatch = typeof urlPattern === 'string'
               ? response.url().includes(urlPattern)
               : urlPattern.test(response.url());
             return urlMatch && response.status() === status;
           },
           { timeout }
         );
       }
       ```

    4. Create `tests/pages/BasePage.ts` — base page object class (INFRA-05):
       ```typescript
       import { Page, Locator } from '@playwright/test';
       import { config } from '../helpers/test-config.js';
       import { retryAction } from '../helpers/retry.js';
       import { waitForSpinnerGone } from '../helpers/waits.js';

       /**
        * Base class for all page objects. Provides:
        * - Navigation with retry (via retryAction)
        * - Explicit wait helpers (no networkidle)
        * - Selector helpers prioritizing role-based > data-testid > text
        */
       export abstract class BasePage {
         constructor(protected readonly page: Page) {}

         /** Path relative to baseURL (e.g., '/login', '/lobby') */
         protected abstract readonly path: string;

         /** Navigate to this page's path with retry logic */
         async goto(): Promise<void> {
           await retryAction(
             async () => {
               await this.page.goto(this.path, {
                 timeout: config.timeouts.navigation,
               });
             },
             { label: `navigate to ${this.path}` }
           );
         }

         /**
          * Wait until the page is "ready" — override in subclasses
          * to wait for page-specific indicators (hero element, data loaded, etc.)
          * Default: wait for spinners to disappear.
          */
         async waitForReady(): Promise<void> {
           await waitForSpinnerGone(this.page);
         }

         /** Navigate and wait for ready state */
         async open(): Promise<void> {
           await this.goto();
           await this.waitForReady();
         }

         /**
          * Selector helper: try data-testid first, fall back to role-based or text.
          * Follows RELY-02 selector priority:
          *   1. getByRole (mirrors accessibility tree)
          *   2. getByLabel (form fields)
          *   3. getByText (visible text)
          *   4. getByTestId (fallback for dynamic content)
          *
          * In practice, page objects should define locators directly using
          * the appropriate Playwright method. This helper is for cases where
          * a data-testid exists and should be preferred.
          */
         protected testIdOrFallback(
           testId: string,
           fallback: () => Locator
         ): Locator {
           // If data-testid exists on the page, prefer it for stability
           // Otherwise use the semantic fallback
           return this.page.getByTestId(testId).or(fallback());
         }
       }
       ```

       Key design decisions:
       - `abstract path` forces subclasses to declare their URL
       - `goto()` wraps navigation in retryAction (RELY-01)
       - `waitForReady()` uses spinner wait, not networkidle (RELY-03)
       - `open()` = goto + waitForReady for common pattern
       - `testIdOrFallback()` implements selector priority (RELY-02)
       - No networkidle anywhere — explicit waits only
  </action>
  <verify>
    - `npx tsc --noEmit` — no TypeScript errors across all helper files
    - `grep -r "networkidle" tests/` — zero results (RELY-03: no networkidle)
    - `grep "retryAction" tests/pages/BasePage.ts` — retry used in navigation
    - `grep "waitForSpinnerGone" tests/pages/BasePage.ts` — explicit wait used
    - `grep "maxAttempts.*3" tests/helpers/test-config.ts` — retry count is 3
  </verify>
  <done>
    Test config module exports timeout constants and retry settings. retryAction() provides generic retry with configurable attempts (default 3). Wait helpers use explicit waitForSelector (not networkidle). BasePage provides goto() with retry, waitForReady() with spinner waits, and testIdOrFallback() for selector strategy.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create page object shells and selector strategy documentation</name>
  <files>
    tests/pages/LobbyPage.ts
    tests/pages/LoginPage.ts
    tests/pages/RegistrationPage.ts
    tests/pages/GameDetailPage.ts
    tests/pages/AccountPage.ts
    docs/SELECTOR-STRATEGY.md
  </files>
  <action>
    1. Create page object shells for each key page. These are structural shells with TODO selectors — actual selectors will be filled in during Phase 2 when we inspect the live site. Each shell must:
       - Extend BasePage
       - Define the `path` property
       - Declare locators as readonly Locator properties (using getByRole/getByTestId)
       - Provide key action methods as stubs
       - Use explicit wait patterns (not networkidle)

    **`tests/pages/LobbyPage.ts`:**
    ```typescript
    import { Page, Locator } from '@playwright/test';
    import { BasePage } from './BasePage.js';

    export class LobbyPage extends BasePage {
      protected readonly path = '/';

      // Locators — update selectors after live site inspection
      readonly searchInput: Locator;
      readonly gameCategories: Locator;
      readonly gameGrid: Locator;
      readonly firstGameTile: Locator;

      constructor(page: Page) {
        super(page);
        this.searchInput = page.getByRole('searchbox').or(
          page.getByTestId('game-search')
        );
        this.gameCategories = page.getByRole('tablist').or(
          page.getByTestId('game-categories')
        );
        this.gameGrid = page.getByTestId('game-grid').or(
          page.getByRole('list', { name: /games/i })
        );
        this.firstGameTile = this.gameGrid.locator('> *').first();
      }

      async searchForGame(query: string): Promise<void> {
        await this.searchInput.fill(query);
      }

      async selectCategory(categoryName: string): Promise<void> {
        await this.page.getByRole('tab', { name: categoryName }).click();
      }

      async clickFirstGame(): Promise<void> {
        await this.firstGameTile.click();
      }

      override async waitForReady(): Promise<void> {
        await super.waitForReady();
        // Wait for game grid to have at least one item
        await this.gameGrid.waitFor({ state: 'visible' });
      }
    }
    ```

    **`tests/pages/LoginPage.ts`:**
    ```typescript
    import { Page, Locator } from '@playwright/test';
    import { BasePage } from './BasePage.js';

    export class LoginPage extends BasePage {
      protected readonly path = '/login';

      readonly emailInput: Locator;
      readonly passwordInput: Locator;
      readonly submitButton: Locator;
      readonly errorMessage: Locator;

      constructor(page: Page) {
        super(page);
        this.emailInput = page.getByRole('textbox', { name: /email/i }).or(
          page.getByTestId('login-email')
        );
        this.passwordInput = page.getByLabel(/password/i).or(
          page.getByTestId('login-password')
        );
        this.submitButton = page.getByRole('button', { name: /sign in|log in|login/i }).or(
          page.getByTestId('login-submit')
        );
        this.errorMessage = page.getByRole('alert').or(
          page.getByTestId('login-error')
        );
      }

      async login(email: string, password: string): Promise<void> {
        await this.emailInput.fill(email);
        await this.passwordInput.fill(password);
        await this.submitButton.click();
      }

      async loginWithEnvCredentials(): Promise<void> {
        const email = process.env.TEST_USER_EMAIL;
        const password = process.env.TEST_USER_PASSWORD;
        if (!email || !password) {
          throw new Error(
            'TEST_USER_EMAIL and TEST_USER_PASSWORD must be set in environment'
          );
        }
        await this.login(email, password);
      }
    }
    ```

    **`tests/pages/RegistrationPage.ts`:**
    ```typescript
    import { Page, Locator } from '@playwright/test';
    import { BasePage } from './BasePage.js';

    export class RegistrationPage extends BasePage {
      protected readonly path = '/register';

      readonly emailInput: Locator;
      readonly passwordInput: Locator;
      readonly usernameInput: Locator;
      readonly submitButton: Locator;
      readonly termsCheckbox: Locator;

      constructor(page: Page) {
        super(page);
        this.emailInput = page.getByRole('textbox', { name: /email/i }).or(
          page.getByTestId('register-email')
        );
        this.passwordInput = page.getByLabel(/password/i).or(
          page.getByTestId('register-password')
        );
        this.usernameInput = page.getByRole('textbox', { name: /username|display name/i }).or(
          page.getByTestId('register-username')
        );
        this.submitButton = page.getByRole('button', { name: /sign up|register|create account/i }).or(
          page.getByTestId('register-submit')
        );
        this.termsCheckbox = page.getByRole('checkbox', { name: /terms|agree/i }).or(
          page.getByTestId('register-terms')
        );
      }

      /** Fill registration form but do NOT submit (stop-before-payment pattern) */
      async fillForm(data: {
        email: string;
        password: string;
        username?: string;
      }): Promise<void> {
        await this.emailInput.fill(data.email);
        await this.passwordInput.fill(data.password);
        if (data.username) {
          await this.usernameInput.fill(data.username);
        }
      }
    }
    ```

    **`tests/pages/GameDetailPage.ts`:**
    ```typescript
    import { Page, Locator } from '@playwright/test';
    import { BasePage } from './BasePage.js';
    import { waitForApiResponse } from '../helpers/waits.js';

    export class GameDetailPage extends BasePage {
      protected readonly path = '/games'; // Will be dynamic: /games/:id

      readonly gameIframe: Locator;
      readonly playButton: Locator;
      readonly gameName: Locator;
      readonly loadingIndicator: Locator;

      constructor(page: Page) {
        super(page);
        this.gameIframe = page.locator('iframe[src*="game"]').or(
          page.getByTestId('game-iframe')
        );
        this.playButton = page.getByRole('button', { name: /play|launch|start/i }).or(
          page.getByTestId('game-play')
        );
        this.gameName = page.getByRole('heading', { level: 1 }).or(
          page.getByTestId('game-name')
        );
        this.loadingIndicator = page.getByTestId('game-loading').or(
          page.getByRole('progressbar')
        );
      }

      /** Navigate to a specific game by slug or ID */
      async gotoGame(gameIdOrSlug: string): Promise<void> {
        await this.page.goto(`/games/${gameIdOrSlug}`);
        await this.waitForReady();
      }

      /** Check if game iframe has loaded */
      async isGameLoaded(): Promise<boolean> {
        return this.gameIframe.isVisible();
      }

      override async waitForReady(): Promise<void> {
        await super.waitForReady();
        // Wait for game name heading to appear
        await this.gameName.waitFor({ state: 'visible' });
      }
    }
    ```

    **`tests/pages/AccountPage.ts`:**
    ```typescript
    import { Page, Locator } from '@playwright/test';
    import { BasePage } from './BasePage.js';

    export class AccountPage extends BasePage {
      protected readonly path = '/account';

      readonly username: Locator;
      readonly email: Locator;
      readonly balanceDisplay: Locator;
      readonly logoutButton: Locator;

      constructor(page: Page) {
        super(page);
        this.username = page.getByTestId('account-username').or(
          page.getByRole('heading', { name: /profile|account/i })
        );
        this.email = page.getByTestId('account-email').or(
          page.getByText(/.*@.*\..*/)
        );
        this.balanceDisplay = page.getByTestId('account-balance').or(
          page.getByRole('status')
        );
        this.logoutButton = page.getByRole('button', { name: /log out|sign out|logout/i }).or(
          page.getByTestId('logout')
        );
      }

      async logout(): Promise<void> {
        await this.logoutButton.click();
      }
    }
    ```

    2. Create `docs/SELECTOR-STRATEGY.md` (RELY-02):
    ```markdown
    # Selector Strategy

    ## Priority Order

    When writing locators in page objects, follow this priority:

    | Priority | Method | When to Use | Example |
    |----------|--------|-------------|---------|
    | 1 | `getByRole()` | Buttons, links, headings, form fields with accessible names | `page.getByRole('button', { name: 'Submit' })` |
    | 2 | `getByLabel()` | Form inputs with associated labels | `page.getByLabel('Email address')` |
    | 3 | `getByText()` | Static visible text content | `page.getByText('Welcome back')` |
    | 4 | `getByTestId()` | Dynamic content, complex components, or when roles are unavailable | `page.getByTestId('game-grid')` |
    | 5 | CSS/XPath | **Last resort only** — iframe src patterns, complex DOM queries | `page.locator('iframe[src*="game"]')` |

    ## Rules

    1. **NEVER use CSS class selectors** (`.btn-primary`, `.game-card`). Classes change with design updates.
    2. **ALWAYS try role-based first.** If it works, stop. Don't add data-testid "just in case."
    3. **Use `.or()` for fallback chains.** Prefer role-based primary with data-testid fallback:
       ```typescript
       page.getByRole('button', { name: /submit/i }).or(page.getByTestId('submit-btn'))
       ```
    4. **No `networkidle` waits.** Use `waitFor({ state: 'visible' })` or `waitForResponse()`.
    5. **No `waitForTimeout()` arbitrary sleeps.** Trust Playwright's auto-waiting on Locator actions.

    ## When data-testid Doesn't Exist

    cooked.com may not have `data-testid` attributes on all elements. Strategy:

    1. First try role-based / label-based selectors (they work without data-testid)
    2. If no semantic selector works, use text-based with regex for flexibility
    3. Document elements that NEED data-testid in a TODO list for the frontend team
    4. Use `.or()` chains so tests work NOW with semantic selectors and will auto-switch when data-testid is added

    ## Pattern: Locator Definition in Page Objects

    ```typescript
    // GOOD: Role-based primary, testid fallback
    readonly submitButton = page.getByRole('button', { name: /submit/i })
      .or(page.getByTestId('form-submit'));

    // GOOD: Label-based for form fields
    readonly emailInput = page.getByLabel('Email address');

    // BAD: CSS class selector
    readonly submitButton = page.locator('.btn-submit');

    // BAD: Deep DOM path
    readonly submitButton = page.locator('form > div:nth-child(3) > button');
    ```

    ## Wait Patterns

    ```typescript
    // GOOD: Wait for specific element
    await element.waitFor({ state: 'visible' });

    // GOOD: Wait for API response
    await page.waitForResponse(resp => resp.url().includes('/api/games'));

    // GOOD: Web-first assertion (auto-retries)
    await expect(element).toBeVisible();

    // BAD: Network idle (hangs in SPAs)
    await page.goto('/', { waitUntil: 'networkidle' });

    // BAD: Arbitrary sleep
    await page.waitForTimeout(3000);
    ```
    ```

    Remove the .gitkeep files from tests/pages/ and tests/helpers/ and docs/ since they now have real files.
  </action>
  <verify>
    - `npx tsc --noEmit` — all page objects and helpers compile without errors
    - `grep -r "extends BasePage" tests/pages/` — all 5 page objects extend BasePage
    - `grep -r "networkidle" tests/` — zero results
    - `grep -r "waitForTimeout" tests/` — zero results
    - `grep -r "getByRole\|getByTestId\|getByLabel\|getByText" tests/pages/` — role-based selectors used
    - `ls docs/SELECTOR-STRATEGY.md` — documentation exists
    - `cat docs/SELECTOR-STRATEGY.md | grep "Priority"` — priority table present
  </verify>
  <done>
    Five page object shells (LobbyPage, LoginPage, RegistrationPage, GameDetailPage, AccountPage) extend BasePage with role-based selectors as primary and data-testid as fallback. No CSS class selectors, no networkidle, no arbitrary sleeps. Selector strategy documented in docs/SELECTOR-STRATEGY.md with priority table, rules, and code examples.
  </done>
</task>

</tasks>

<verification>
Run these checks to verify Plan 02 is complete:

1. `npx tsc --noEmit` — full project compiles
2. `grep -rn "extends BasePage" tests/pages/` — all 5 page objects
3. `grep -rn "networkidle\|waitForTimeout" tests/` — zero results (no forbidden patterns)
4. `grep -rn "getByRole" tests/pages/` — role-based locators used across pages
5. `grep -rn "retryAction" tests/helpers/retry.ts tests/pages/BasePage.ts` — retry wired into BasePage
6. `ls tests/helpers/test-config.ts tests/helpers/retry.ts tests/helpers/waits.ts` — all helpers exist
7. `ls tests/pages/BasePage.ts tests/pages/LobbyPage.ts tests/pages/LoginPage.ts tests/pages/RegistrationPage.ts tests/pages/GameDetailPage.ts tests/pages/AccountPage.ts` — all page objects exist
8. `cat docs/SELECTOR-STRATEGY.md` — non-empty, contains selector priority
</verification>

<success_criteria>
- All TypeScript files compile without errors
- BasePage provides goto() with retry, waitForReady() without networkidle, and testIdOrFallback()
- retryAction() retries 3 times with configurable delay
- All 5 page objects (Lobby, Login, Registration, GameDetail, Account) extend BasePage
- Every locator uses getByRole/getByLabel/getByText/getByTestId — no CSS class selectors
- Zero occurrences of networkidle or waitForTimeout in test code
- Selector strategy documented with priority order, rules, and examples
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-test-infrastructure/01-02-SUMMARY.md`
</output>

---
phase: 03-social-live-features
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/pages/ChatPage.ts
  - tests/social/chat-connection.spec.ts
  - tests/social/chat-messages.spec.ts
autonomous: true

must_haves:
  truths:
    - "Chat WebSocket connection establishes successfully on chat page load"
    - "Chat messages are visible in the chat interface after connection"
  artifacts:
    - path: "tests/pages/ChatPage.ts"
      provides: "Chat page object with WebSocket-aware locators and tipping helpers"
      contains: "extends BasePage"
    - path: "tests/social/chat-connection.spec.ts"
      provides: "WebSocket connection establishment test"
      contains: "@critical @social"
    - path: "tests/social/chat-messages.spec.ts"
      provides: "Chat message visibility test"
      contains: "@critical @social"
  key_links:
    - from: "tests/social/chat-connection.spec.ts"
      to: "tests/pages/ChatPage.ts"
      via: "import ChatPage"
      pattern: "import.*ChatPage"
    - from: "tests/social/chat-messages.spec.ts"
      to: "tests/pages/ChatPage.ts"
      via: "import ChatPage"
      pattern: "import.*ChatPage"
    - from: "tests/pages/ChatPage.ts"
      to: "tests/pages/BasePage.ts"
      via: "extends BasePage"
      pattern: "extends BasePage"
---

<objective>
Create the ChatPage page object and WebSocket-based chat tests (SOCIAL-01, SOCIAL-02) validating that the chat WebSocket connection establishes on page load and that chat messages are visible in the interface.

Purpose: Chat is a known fragile area on cooked.com. WebSocket connection health is a leading indicator of backend stability. If WebSocket fails to connect or messages don't render, the entire social feature set is broken for users.
Output: 1 ChatPage page object in tests/pages/, 2 test spec files in tests/social/ covering WebSocket connection and message visibility.
</objective>

<execution_context>
@C:/Users/Karl/.claude/get-shit-done/workflows/execute-plan.md
@C:/Users/Karl/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@tests/pages/BasePage.ts
@tests/pages/LobbyPage.ts
@tests/helpers/test-config.ts
@tests/helpers/waits.ts
@playwright.config.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ChatPage page object with WebSocket-aware locators</name>
  <files>tests/pages/ChatPage.ts</files>
  <action>
Create `tests/pages/ChatPage.ts` extending BasePage:

**Path:** `/chat` (or `/live-chat` — use a TODO comment noting path should be verified against live site)

**Locators (all using role-based primary with .or() data-testid fallback):**
- `chatContainer`: The main chat wrapper — `page.getByTestId('chat-container').or(page.getByRole('log').or(page.locator('[class*="chat"], [id*="chat"]').first()))` — chat regions often use role="log" for accessibility
- `chatMessages`: All visible chat message elements — `chatContainer.getByRole('listitem').or(chatContainer.locator('[data-testid="chat-message"], [class*="message"]'))` — individual message items
- `chatInput`: Message input field — `page.getByRole('textbox', { name: /message|chat/i }).or(page.getByTestId('chat-input'))`
- `tipButton`: Tip/gift button in chat — `page.getByRole('button', { name: /tip|gift|send tip/i }).or(page.getByTestId('tip-button'))`
- `tipModal`: Tip modal/dialog container — `page.getByRole('dialog', { name: /tip/i }).or(page.getByTestId('tip-modal'))`
- `tipAmountOptions`: Selectable tip amount buttons — `tipModal.getByRole('button', { name: /\$\d+/ }).or(tipModal.getByTestId('tip-amount'))`
- `selectedTipAmount`: Currently selected/displayed tip amount — `tipModal.locator('[aria-selected="true"], [data-selected], .selected').or(tipModal.getByTestId('selected-amount'))`
- `confirmTipButton`: Confirm tip button inside modal — `tipModal.getByRole('button', { name: /confirm/i }).or(tipModal.getByTestId('confirm-tip'))`
- `tipConfirmationDialog`: Second confirmation step — `page.getByRole('alertdialog').or(page.getByTestId('tip-confirmation'))`
- `submitTipButton`: Final submit button (DO NOT CLICK in tests) — `tipConfirmationDialog.getByRole('button', { name: /submit|send|confirm/i }).or(tipConfirmationDialog.getByTestId('submit-tip'))`
- `cancelTipButton`: Cancel button in tip dialogs — `tipModal.getByRole('button', { name: /cancel|close/i }).or(tipModal.getByTestId('cancel-tip'))`

**Methods:**
- `sendMessage(text: string)`: Fill chatInput and press Enter — for future use, not needed for SOCIAL-01/02 but included for completeness
- `clickTipButton()`: Click the tip button
- `selectTipAmount(amount: string)`: Click the tip amount button matching the dollar amount (e.g., '5' clicks the $5 button)
- `clickConfirmTip()`: Click the confirm button in tip modal
- `clickCancelTip()`: Click the cancel button in tip modal

**Override waitForReady():**
- Call `super.waitForReady()` (spinner wait)
- Then wait for `chatContainer` to be visible with 10s timeout

Add JSDoc comment at class level explaining: "Chat page object for WebSocket-based chat interface. Includes locators for chat messages and tipping flow. All locators use .or() chains — update selectors after live site inspection."

Add TODO comments on locators that need live site verification: chat container structure, message item selectors, tip button location.

Follow existing patterns from LobbyPage.ts: constructor initializes all locators, readonly properties, ESM .js import for BasePage.
  </action>
  <verify>
Run `npm run typecheck` — no TypeScript errors.
Verify ChatPage extends BasePage.
Verify ChatPage has chatContainer, chatMessages, chatInput, tipButton, tipModal locators.
Verify ChatPage has sendMessage, clickTipButton, selectTipAmount, clickConfirmTip methods.
  </verify>
  <done>
ChatPage.ts exists in tests/pages/, extends BasePage, has all locators for chat container, messages, input, and tipping flow. All locators use .or() fallback chains. waitForReady() overridden to wait for chat container. TypeScript compiles without errors.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create chat WebSocket connection and message visibility tests (SOCIAL-01, SOCIAL-02)</name>
  <files>tests/social/chat-connection.spec.ts, tests/social/chat-messages.spec.ts</files>
  <action>
Create the `tests/social/` directory if it doesn't exist.

**Create `tests/social/chat-connection.spec.ts` for SOCIAL-01:**
- Import `test, expect` from `@playwright/test`
- Import `ChatPage` from `../pages/ChatPage.js`
- Single test: `'chat WebSocket connection establishes successfully @critical @social'`
- **CRITICAL: Set up WebSocket listener BEFORE navigation** (research pitfall 1 — connections establish during page load)
- Create `const wsPromise = page.waitForEvent('websocket', { predicate: (ws) => ws.url().includes('/chat') || ws.url().includes('/ws') || ws.url().includes('socket'), timeout: 15_000 })`
- Add a TODO comment: `// TODO: Refine WebSocket URL predicate after inspecting live site DevTools Network tab (WS filter)`
- Create ChatPage and navigate: `const chatPage = new ChatPage(page); await chatPage.goto();`
- Wait for WebSocket: `const webSocket = await wsPromise;`
- Assert WebSocket is open: `expect(webSocket.isClosed()).toBe(false);`
- Assert WebSocket URL matches expected pattern: `expect(webSocket.url()).toMatch(/chat|ws|socket/i);`
- Tag: `@critical @social`

**Create `tests/social/chat-messages.spec.ts` for SOCIAL-02:**
- Import `test, expect` from `@playwright/test`
- Import `ChatPage` from `../pages/ChatPage.js`
- Single test: `'chat messages are visible in the interface @critical @social'`
- Create ChatPage and open (includes waitForReady): `const chatPage = new ChatPage(page); await chatPage.open();`
- Wait for chat container: `await expect(chatPage.chatContainer).toBeVisible({ timeout: 10_000 });`
- Wait for at least one chat message to appear with generous timeout (real-time apps may take time to show messages): `await expect(chatPage.chatMessages.first()).toBeVisible({ timeout: 15_000 });`
- Assert the first message has non-empty text content: `const messageText = await chatPage.chatMessages.first().textContent(); expect(messageText).toBeTruthy(); expect(messageText!.trim().length).toBeGreaterThan(0);`
- Assert multiple messages exist (chat should show history or active messages): `const messageCount = await chatPage.chatMessages.count(); expect(messageCount).toBeGreaterThan(0);`
- Do NOT inspect WebSocket frame payloads (research anti-pattern — test DOM, not protocol)
- Do NOT use waitForTimeout (use auto-waiting toBeVisible with timeout instead)
- Tag: `@critical @social`

Both files: ESM imports with .js extensions. No networkidle. No waitForTimeout. No frame payload inspection.
  </action>
  <verify>
Run `npx playwright test tests/social/ --list` — both tests listed.
Run `npm run typecheck` — no TypeScript errors.
Run `npx playwright test --grep @social --list` — both social tests appear.
Verify chat-connection.spec.ts sets up WebSocket listener BEFORE navigation (waitForEvent before goto).
Verify chat-messages.spec.ts uses DOM assertions (toBeVisible, textContent) not WebSocket frame inspection.
  </verify>
  <done>
chat-connection.spec.ts: Test listed, sets up WebSocket listener before navigation, asserts connection open and URL matches pattern, tagged @critical @social.
chat-messages.spec.ts: Test listed, waits for chat container and messages via DOM assertions, asserts messages have text content, tagged @critical @social.
TypeScript compiles without errors. No networkidle, waitForTimeout, or frame payload inspection.
  </done>
</task>

</tasks>

<verification>
- tests/pages/ChatPage.ts exists and extends BasePage
- tests/social/ directory exists with 2 spec files
- ChatPage has locators for chatContainer, chatMessages, chatInput, tipButton, tipModal, and tipping flow
- chat-connection.spec.ts registers WebSocket listener BEFORE page navigation
- chat-messages.spec.ts uses DOM-based assertions (not WebSocket frame inspection)
- All tests tagged @critical @social
- No networkidle, waitForTimeout, or CSS class-only selectors
- TypeScript compiles: `npm run typecheck` passes
- All tests appear in `npx playwright test --grep @social --list`
</verification>

<success_criteria>
- ChatPage page object created with chat and tipping locators, extending BasePage
- 2 social test spec files exist and are listed by Playwright
- Tests cover SOCIAL-01 (WebSocket connection) and SOCIAL-02 (chat message visibility)
- WebSocket listener set up before navigation (not after)
- DOM-based message assertions (not protocol-level)
- All tests tagged @critical @social
- TypeScript compiles without errors
- No forbidden patterns (networkidle, waitForTimeout)
</success_criteria>

<output>
After completion, create `.planning/phases/03-social-live-features/03-01-SUMMARY.md`
</output>
